---
title: 'Thanks for inventing JavaScript'
published: 2021-08-19
edited: 2025-10-25
cover: '/res/cover/2021-thanks-js.png'
tags:
- 'JavaScript'
- '언어'
- '투정'
---

import { Image } from 'astro:assets';
import AOut from '@components/post/a/AOut.astro';
import AWp from '@components/post/a/AWp.astro';
import ADoi from '@components/post/a/ADoi.astro';
import Blockquote from '@components/post/Blockquote.astro';
import Term from '@components/post/Term.astro';
import Fn from '@components/post/fn/Fn.astro';
import Tn from '@components/post/fn/Tn.astro';
import Ref from '@components/post/fn/Ref.astro';

import Var from './Var.astro';
import h from './href.ts';

import original from './original.png';
import x_1426610751238590467 from './x-1426610751238590467.png';
import js from './js.png';
import ieee754 from './ieee754.png';

<Image src={original} alt={`'Thanks for inventing JavaScript' 밈 이미지. JavaScript의 특이한 코드 실행 결과 여러 개가 나열되어 있고, 그 밑에 JavaScript의 최초 개발자 브렌던 아이크의 웃는 얼굴과 함께 "Thanks for inventing Javascript"라는 문구가 있다.`} />

어린 시절(나이가 1자리 수였을 때로 기억하고 있습니다)에 HTML 학습 사이트에 올라온 자바스크립트 달력 코드를 보고 따라해본 적이 있었습니다(실패했습니다). 또 나이가 더 들고 나서는 유명한 웹게임인 <AOut href="https://orteil.dashnet.org/cookieclicker">Cookie Clicker</AOut>의 한국어 번역 플러그인을 만들다가 던진 기억이 있습니다.

글 시작부터 좀 뜬금없는 얘기를 하긴 했는데, 아무튼 이런저런 이유로 자바스크립트가 마음의 고향인 저에게 이 "Thanks for inventing JavaScript" 짤을 보면 자바스크립트를 억지로 까고 있는 것 같아 신경쓰이는 점이 한두 가지가 아닙니다.

2022년에 이 신경쓰이는 점을 못 이겨 이 블로그 글을 처음 작성했고 2024년 1월 10일 당시 시크릿 모드로 Google에 `thanks for inventing javascript`을 검색한 결과에 첫 번째로 올라와 있었는데, <AOut href="https://velog.io/@bami/Thanks-for-inventing-Javascript">두 번째로 올라와 있는 이 글</AOut>을 문득 읽어보니 제가 처음 썼던 글보다 훨씬 정성이 느껴져 부끄러웠습니다. 그런 의미로 원래보다 더 길고 자세하게 글을 재작성했는데, 더 깊이 있는 글이 되었으면 좋겠습니다.

이 글에서 언급하는 표준 문서는 <Ref id="ECMA262"/>로, 독자의 편의를 위해 글쓴이가 임의로 번역했습니다. 해당 표준에서 정의해서 사용하는 내부 연산 및 표기도 그대로 옮겼지만, 글을 이해하는 데 필요한 것은 아니고 알고리즘의 전체적인 흐름만 이해하면 됩니다. 단, 아래 표기는 알아두는 것이 좋습니다.

* <Var>청록색 기울임꼴</Var>로 된 텍스트는 <AOut href={h.notation.alg.$}>그 알고리즘에서 사용하는 변수명입니다</AOut>.
* **굵은** 텍스트는 <AOut href={h.notation.alg.value}>JavaScript 값입니다</AOut>.
* JavaScript의 Number 값은 <AOut href={h.notation.alg.math}>아래 첨자 $$\mathbb{F}$$를 붙여 수학적 실수 값과 구분합니다</AOut>.
* 연산 앞에 물음표(?)가 붙는 경우는 <AOut href={h.notation.alg.runtime.returnifabrupt_short}>'그 연산이 (`break`, `continue`, `return`, `throw` 등에 의해) 비정상적으로 종료된 경우 즉시 반환한다'고 해석할 수 있습니다</AOut>. 일종의 예외 처리인 것으로 생각할 수 있으며, 무시하고 읽어도 큰 문제는 없습니다.
	* 비슷하게 연산 앞에 느낌표(!)가 붙는 경우는 '그 연산은 비정상적으로 종료되지 않는다'는 불변조건으로 해석할 수 있습니다. 역시 무시해도 됩니다.

참고로 구글 이미지검색을 해본 결과 이 이미지는 2018년 6월 21일에 <AOut href="https://www.reddit.com/r/ProgrammerHumor/comments/8srix1/thanks_brendan_for_giving_us_the_javascript/">레딧의 r/ProgrammerHumor에 처음 올라왔던 것</AOut>으로 보입니다. 이 이전의 검색결과 중 실제로 해당 이미지가 있는 페이지는 찾지 못했습니다.

## `typeof NaN` \{#typeof-nan\}

### 어떻게 된 걸까? \{#typeof-nan-what-happened\}

`typeof` 연산자의 <AOut href={h.expr.unary.typeof.eval}>13.5.3.1 <Term term="Runtime Semantics: Evaluation">런타임 의미론: 평가</Term></AOut>에서 `typeof` 연산자의 알고리즘을 확인할 수 있는데, 중요하게 볼 만한 부분만 간추리면 이렇습니다.

<Blockquote>
	*UnaryExpression* : `typeof` <Var>UnaryExpression</Var>

	<ol>
		<li><Var>val</Var>을 <AOut href={h.expr.unary.prod}><Var>UnaryExpression</Var></AOut>의 ? <AOut href={h.syn.eval}>평가값</AOut>으로 정한다.</li>
		<li>(중략)</li>
		<li value="9"><Var>val</Var>이 <AOut href={h.type.lang.numeric.number.$}>Number일</AOut> 경우, <strong>"number"</strong>를 반환한다.</li>
	</ol>

	<Fragment slot="original">
		*UnaryExpression* : `typeof` <Var>UnaryExpression</Var>

		<ol>
			<li>Let <Var>val</Var> be ? <AOut href={h.syn.eval}>Evaluation</AOut> of <AOut href={h.expr.unary.prod}><Var>UnaryExpression</Var></AOut>.</li>
			<li>...</li>
			<li value="9">If <Var>val</Var> <AOut href={h.type.lang.numeric.number.$}>is a Number</AOut>, return <strong>"number"</strong>.</li>
		</ol>
	</Fragment>
</Blockquote>

그런데 <AOut href={h.type.lang.numeric.number.$}>6.1.6.1 <Term term="The Number Type">Number 타입</Term></AOut>에서는 `NaN`도 Number인 것으로 정의하고 있습니다.<Fn id="ecma262-language-types" />

<Blockquote>
	*Number 타입*은 정확히 18,437,736,874,454,810,627(즉, $$2^{64} - 2^{53} + 3$$)개의 값을 가지고, 배정밀도 부동소수점의 <ADoi doi="10.1109/IEEESTD.2019.8766229" restricted>IEEE 754-2019</ADoi> binary64 값을 IEEE 이진 부동소수점 산술 표준에서 명시한 대로 나타내나, IEEE 표준의 9,007,199,254,740,990(즉, $$2^{53} - 2$$)개의 서로 다른 NaN 값은 ECMAScript에서 특수한 단일 **NaN** 값으로 나타내어진다. (**NaN** 값은 프로그램 식 `NaN`으로 생성됨에 유의하라.) ...

	<Fragment slot="original">
		The *Number type* has exactly 18,437,736,874,454,810,627 (that is, $$2^{64} - 2^{53} + 3$$) values, representing the double-precision floating point <ADoi doi="10.1109/IEEESTD.2019.8766229" restricted>IEEE 754-2019</ADoi> binary64 values as specified in the IEEE Standard for Binary Floating-Point Arithmetic, except that the 9,007,199,254,740,990 (that is, $$2^{53} - 2$$) distinct NaN values of the IEEE Standard are represented in ECMAScript as a single special **NaN** value. (Note that the **NaN** value is produced by the program expression `NaN`.) ...
	</Fragment>
</Blockquote>

### 무엇이 문제일까? \{#typeof-nan-what-went-wrong\}

바로 위의 인용문에서 주목할 점이 있습니다.

> ... IEEE 표준의 9,007,199,254,740,990(즉, $$2^{53} - 2$$)개의 서로 다른 NaN 값은 ...

NaN 값은 애초에 **IEEE 754 표준**에서 정의하는 값이고, 절대 다수의 부동소수점 연산이 IEEE 754를 따르기 때문에 JavaScript에서도 포함하고 있습니다. 하필이면 이 값에 '수가 아니다'라는 의미의 이름이 붙었고 JavaScript가 기본 수 타입에 `"number"`라는 이름을 붙여버려서 혼란이 생겼다는 느낌이 들긴 합니다.

### 다른 언어에서도 그럴까? \{#typeof-nan-do-other-languages-do-this\}

네. NaN이 있는 다른 언어에서도 NaN은 다른 부동소수점 실수와 똑같은 타입을 가지고, JavaScript만 NaN을 다른 타입으로 취급한다면 오히려 이상할 것입니다.

```cpp
#include <iostream>
#include <cmath>
#include <typeinfo>

template<class T> void print_type(T x) {
	std::cout << typeid(x).name() << " " << x << std::endl;
}

int main() {
    double
		number = 12.34,
		not_a_number = 0./0.,
		explicit_nan = NAN;

	/*
		`typeid(...).name()`은 컴파일러에 따라 다른 값을 반환할 수 있지만,
		같은 컴파일러에서 같은 타입이면 같은 문자열을 반환합니다.
	*/
	print_type(number); // d 12.34
	print_type(not_a_number); // d nan
	print_type(explicit_nan); // d nan
    return 0;
}
```

```python
from math import nan

def print_type(x):
	print(type(x), x)

print_type(1.) # <class 'float'> 1.0
# Python에서는 0으로 나누면 NaN을 반환하는 대신 ZeroDivisionError가 발생합니다.
# print_type(0./0.)
print_type(nan) # <class 'float'> nan
```

## `9999 9999 9999 9999` \{#9999999999999999\}

이 단락을 포함해 길이가 긴 수를 작성할 때는 독자의 편의를 위해 네 자리마다 띄어쓰기로 자릿수를 구분합니다.

### 어떻게 된 걸까? \{#9999999999999999-what-happened\}

**이것도 IEEE 754 문제입니다.**

`9999 9999 9999 9999`를 이진법으로 쓰면 `10 0011 1000 0110 1111 0010 0110 1111 1100 0000 1111 1111 1111 1111`이고 맨 앞의 1을 제외하면 <Term term="significand">가수</Term><Tn id="significand" />가 53자리인데, 배정밀도 부동소수점은 가수가 52자리밖에 없어 이 값을 표현할 수 없습니다. 그 대신 가장 가까운 표현 가능한 값으로 반올림한 결과가 `1 0000 0000 0000 0000`입니다.

아니면 <AOut href="https://float.exposed/0x4341c37937e08000">float.exposed</AOut>에 부동소수점 값을 입력하면 그 값의 내부 표현을 볼 수 있는데, `9999 9999 9999 9999`의 경우 `1 0000 0000 0000 0000.0`으로 반올림되고, 그 부호-지표-가수 값이 다음과 같습니다.

* <Term term="sign">부호</Term> = `0`
	* `0`이면 양수, `1`이면 음수입니다.
* <Term term="exponent">지표</Term> = `1076`
	* 이 값에서 `1023`을 뺀 값이 소수점의 위치가 됩니다. $$1076 - 1023 = 53$$이므로 소수점이 (이진법 표현에서) 왼쪽으로 53자리 이동합니다.
* <Term term="significand">가수</Term> = `496 4003 7262 9504`
	* 이 값은 이진법으로 `0001 1100 0011 0111 1001 0011 0111 1110 0000 1000 0000 0000 0000`인데(위에서 언급했듯이 52자리입니다), 이 앞에 `1.`을 붙인 `1.0001 1100 0011 0111 1001 0011 0111 1110 0000 1000 0000 0000 0000`에서 소수점을 적절히 움직인 것이 실제 값이 됩니다.

여기서 가수를 1 내리면 아니나다를까 `9999 9999 9999 9998.0`이 됩니다.

### 다른 언어에서도 그럴까? \{#9999999999999999-do-other-languages-do-this\}

네.

```c
#include <stdio.h>

int main(void) {
	double gazillion = 9999999999999999.;
    printf("%f\n", gazillion); // 10000000000000000.000000
    return 0;
}
```

### 해결할 수 있을까? \{#9999999999999999-can-we-fix-it\}

진짜로 정수 `9999 9999 9999 9999`를 정확히 표현하고 싶다면 <AOut href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/BigInt">BigInt</AOut> `9999_9999_9999_9999n`을 쓰면 됩니다<Fn id="numeric-separator" />. 단, 소수는 표현할 수 없으며 BigInt끼리만 연산할 수 있습니다.

## `0.1+0.2==0.3` \{#0-1-plus-0-2-eq-0-3\}

### 어떻게 된 걸까? \{#0-1-plus-0-2-eq-0-3-what-happened\}

**이것도 IEEE 754 문제입니다.**

역시 float.exposed(무관하지만 주소가 외우기 정말 좋네요)에 `0.1`, `0.2`, `0.3`, `0.3000 0000 0000 0000 4`를 입력하면 이렇게 됩니다.

* `0.1` → `0.1000 0000 0000 0000 0555 1`
	* 부호 = `0`
	* 지표 = `1019`
	* 가수 = `2702 1597 7642 2298` (십진법), `1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1010` (이진법)
* `0.2` → `0.2000 0000 0000 0000 1110 2`
	* 부호 = `0`
	* 지표 = `1020`
	* 가수 = `2702 1597 7642 2298` (십진법), `1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1010` (이진법)
* `0.3` → `0.2999 9999 9999 9999 8889 8`
	* 부호 = `0`
	* 지표 = `1021`
	* 가수 = `900 7199 2547 4099` (십진법), `0011 0011 0011 0011 0011 0011 0011 0011 0011 0011 0011 0011 0011` (이진법)
* `0.3000 0000 0000 0000 4` → `0.3000 0000 0000 0000 4440 9`
	* 부호 = `0`
	* 지표 = `1021`
	* 가수 = `900 7199 2547 4100` (십진법), `0011 0011 0011 0011 0011 0011 0011 0011 0011 0011 0011 0011 0100` (이진법)
		* 바로 위의 `0.3`보다 가수만 1 큽니다.

`0.1` `0.2` `0.3` 모두 이진법으로 표현하면 순환소수가 되기 때문에 가장 가까운 부동소수점으로 반올림이 되는데, 이때 생긴 오류가 누적되면서 생기는 현상입니다.

바로 위 줄에서는 `0.5+0.1==0.6`이 성립하는데, 이는 `0.5`가 배정밀도 부동소수점으로 정확히 표현 가능하기 때문입니다.

* `0.5`
	* 부호 = `0`
	* 지표 = `1022`
	* 가수 = `0` (십진법), `0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000` (이진법)

### 다른 언어에서도 그럴까? \{#0-1-plus-0-2-eq-0-3-do-other-languages-do-this\}

[게임메이커 언어에도 이 문제가 있어서 블로그에서 언급한 적이 있습니다](/2020/gms-tips#0-1-plus-0-2-neq-0-3). 심지어 <strong><AOut href="https://0.30000000000000004.com">유명한 프로그래밍 언어에서 0.1 + 0.2를 한 결과를 모은 웹페이지</AOut></strong>도 있습니다.

## `Math.max()` \{#math-max\}

### 어떻게 된 걸까? \{#math-max-what-happened\}

<AOut href={h.num.math.fn.max}>21.3.2.25 Math.max(...<Var>args</Var>)</AOut>에서 이 함수의 알고리즘을 확인할 수 있습니다.

<Blockquote>
	1. <Var>coerced</Var>를 새로운 비어 있는 <AOut href={h.type.spec.list}>리스트</AOut>로 정한다.
	1. <Var>args</Var>의 각 원소 <Var>arg</Var>마다,
		<ol style="list-style-type: lower-alpha;">
			<li><Var>n</Var>을 ? <AOut href={h.abs.conv.tonumber.$}>ToNumber</AOut>(<Var>arg</Var>)로 정한다.</li>
			<li><Var>coerced</Var>의 맨 끝에 <Var>n</Var>을 추가한다.</li>
		</ol>
	1. <Var>highest</Var>를 $$-\infty_\mathbb{F}$$로 정한다.
	1. <Var>coerced</Var>의 각 원소 <Var>number</Var>마다,
		<ol style="list-style-type: lower-alpha;">
			<li><Var>number</Var>가 **NaN**이면, **NaN**을 반환한다.</li>
			<li><Var>number</Var>가 $$+0_\mathbb{F}$$이고 <Var>highest</Var>가 $$-0_\mathbb{F}$$이면, <Var>highest</Var>를 $$+0_\mathbb{F}$$로 바꾼다.</li>
			<li><Var>number</Var> > <Var>highest</Var>이면, <Var>highest</Var>를 <Var>number</Var>로 바꾼다.</li>
		</ol>
	1. <Var>highest</Var>를 반환한다.

	<Fragment slot="original">
		1. Let <Var>coerced</Var> be a new empty <AOut href={h.type.spec.list}>List</AOut>.
		1. For each element <Var>arg</Var> of <Var>args</Var>,
			<ol style="list-style-type: lower-alpha;">
				<li>Let <Var>n</Var> be ? <AOut href={h.abs.conv.tonumber.$}>ToNumber</AOut>(<Var>arg</Var>).</li>
				<li>Append <Var>n</Var> to <Var>coerced</Var>.</li>
			</ol>
		1. Let <Var>highest</Var> be $$-\infty_\mathbb{F}$$.
		1. For each element <Var>number</Var> of <Var>coerced</Var>,
			<ol style="list-style-type: lower-alpha;">
				<li>If <Var>number</Var> is **NaN**, return **NaN**.</li>
				<li>If <Var>number</Var> is $$+0_\mathbb{F}$$ and <Var>highest</Var> is $$-0_\mathbb{F}$$, set <Var>highest</Var> to $$+0_\mathbb{F}$$.</li>
				<li>If <Var>number</Var> > <Var>highest</Var>, set <Var>highest</Var> to <Var>number</Var>.</li>
			</ol>
		1. Return <Var>highest</Var>.
	</Fragment>
</Blockquote>

이때 <Var>args</Var>가 빈 배열이면 <Var>coerced</Var>도 빈 리스트가 되고, 4번 단계가 실행되지 않기 때문에 <Var>highest</Var>의 초깃값인 $$-\infty_\mathbb{F}$$, 즉 `-Infinity`를 반환합니다.

<AOut href={h.num.math.fn.min}>21.3.2.26 Math.min(...<Var>args</Var>)</AOut>도 무한대의 부호와 부등호의 방향을 제외하면 같은 알고리즘을 사용합니다.

### 무엇이 문제일까? \{#math-max-what-went-wrong\}

`Math.max`는 애초에 **인자로 주어진 수 중에** 가장 큰 수를 구하는 함수지, 무턱대고 가장 큰 수를 반환하는 함수가 아닙니다. `-Infinity`가 아니라 `Infinity`일 이유가 전혀 없습니다.

인자를 0개 전달받았을 때 그냥 `throw`를 해도 되긴 하지만, `-Infinity`를 반환하겠다면 그 이유를 수학적으로 정당화할 수 있습니다. (실수의) 덧셈에는 **<AWp lang="ko" art="항등원" />**, 즉 $$a + e = a$$와 $$e + a = a$$를 만족하는 $$e = 0$$이 있고, 모든 덧셈은 암묵적으로 항등원이 붙는 것으로 생각할 수 있습니다.

$$
a + b + c = 0 + a + b + c
$$

즉, "0개의 수를 더하는 것"은 "덧셈의 항등원에 0개의 수를 더하는 것", 즉 그냥 덧셈의 항등원이 되는 것으로 이해할 수 있습니다.

$$
\sum_{x \in \emptyset} x = 0
$$

한편 $$\max$$ 연산에도 $$\max(a, e) = a$$와 $$\max(e, a) = a$$를 만족하는 항등원이 있는데, 이 값이 다름아닌 **$$-\infty$$입니다**.<Fn id="max-identity" /> 즉, 위와 같은 논리로 0개의 수의 최댓값은 $$-\infty$$인 것으로 생각할 수 있습니다. 이 논리는 `Math.min() == Infinity`에도 똑같이 적용할 수 있습니다.<Fn id="supremum" />

### 해결할 수 있을까? \{#math-max-can-we-fix-it\}

JavaScript에서 각 분야별로 가장 큰/작은 Number 타입의 수는 다음과 같이 구할 수 있습니다.

* 가장 큰/작은 수: `Infinity`/`-Infinity`
* 가장 큰 유한수: `Number.MAX_VALUE` = `1.7976 9313 4862 3157e+308`
* 정확히 나타낼 수 있는 가장 큰/작은 정수: `Number.MAX_SAFE_INTEGER` = `9007 1992 5474 0991`/`Number.MIN_SAFE_INTEGER` = `-9007 1992 5474 0991`
* 가장 작은 양수: `Number.MIN_VALUE` = `5e-324`

## `[]+[]`, `[]+{}`, `{}+[]` \{#array-plus-array\}

`(!+[]+[]+![]).length`, `9+"1"`, `91-"1"`은 생략하겠습니다.

### 어떻게 된 걸까? \{#array-plus-array-what-happened\}

<AOut href={h.expr.additive.add.eval}>덧셈 연산자의 의미</AOut>는 <AOut href={h.expr.assign.evaluatestringornumericbinaryexpression}>13.15.4 EvaluateStringOrNumericBinaryExpression(<Var>leftOperand</Var>, <Var>opText</Var>, <Var>rightOperand</Var>)</AOut>를 거쳐 <AOut href={h.expr.assign.applystringornumericbinaryoperator}>13.15.3 ApplyStringOrNumericBinaryOperator(<Var>lVal</Var>, <Var>opText</Var>, <Var>rVal</Var>)</AOut>에서 정의됩니다. 이 글에서 중요하게 볼 만한 부분만 간추리면 다음과 같으며, 이 경우에는 <Var>opText</Var>가 `+`입니다.

<Blockquote>
	1. <Var>opText</Var>가 `+`일 경우,
		<ol style="list-style-type: lower-alpha;">
			<li><Var>lPrim</Var>을 ? <AOut href={h.abs.conv.toprimitive}>ToPrimitive</AOut>(<Var>lVal</Var>)로 정한다.</li>
			<li><Var>rPrim</Var>을 ? <AOut href={h.abs.conv.toprimitive}>ToPrimitive</AOut>(<Var>rVal</Var>)로 정한다.</li>
			<li>
				<Var>lPrim</Var>이 <AOut href={h.type.lang.string.$}>String이거나</AOut> <Var>rPrim</Var>이 <AOut href={h.type.lang.string.$}>String일</AOut> 경우,
				<ol style="list-style-type: lower-roman;">
					<li><Var>lStr</Var>을 ? <AOut href={h.abs.conv.tostring}>ToString</AOut>(<Var>lPrim</Var>)으로 정한다.<Fn id="tostring" /></li>
					<li><Var>rStr</Var>을 ? <AOut href={h.abs.conv.tostring}>ToString</AOut>(<Var>rPrim</Var>)으로 정한다.</li>
					<li><Var>lStr</Var>와 <Var>rStr</Var>의 <AOut href={h.type.lang.string.concat}>연결문자열</AOut>을 반환한다.</li>
				</ol>
			</li>
			<li>(후략)</li>
		</ol>
	1. (후략)

	<Fragment slot="original">
		1. If <Var>opText</Var> is `+`,
			<ol style="list-style-type: lower-alpha;">
				<li>Let <Var>lPrim</Var> be ? <AOut href={h.abs.conv.toprimitive}>ToPrimitive</AOut>(<Var>lVal</Var>).</li>
				<li>Let <Var>rPrim</Var> be ? <AOut href={h.abs.conv.toprimitive}>ToPrimitive</AOut>(<Var>rVal</Var>).</li>
				<li>
					If <Var>lPrim</Var> <AOut href={h.type.lang.string.$}>is a String</AOut> or <Var>rPrim</Var> <AOut href={h.type.lang.string.$}>is a String</AOut>,
					<ol style="list-style-type: lower-roman;">
						<li>Let <Var>lStr</Var> be ? <AOut href={h.abs.conv.tostring}>ToString</AOut>(<Var>lPrim</Var>).</li>
						<li>Let <Var>rStr</Var> be ? <AOut href={h.abs.conv.tostring}>ToString</AOut>(<Var>rPrim</Var>).</li>
						<li>Return the <AOut href={h.type.lang.string.concat}>string-concatenation</AOut> of <Var>lStr</Var> and <Var>rStr</Var>.</li>
					</ol>
				</li>
				<li>...</li>
			</ol>
		1. ...
	</Fragment>
</Blockquote>

여기서 <AOut href={h.abs.conv.toprimitive}>7.1.1 ToPrimitive(<Var>input</Var>[, <Var>preferredType</Var>])</AOut>는 Object인 값을 Object가 아닌 원시값으로 바꾸는 연산이며, `[]`와 `{}`의 경우에는 모두 `.toString()`을 호출하는 연산이 됩니다.

`[]+[]`와 `[]+{}`은 모두 이항 덧셈 연산자의 의미로 설명할 수 있습니다.

* `[].toString()` = `""`이므로 `[]+[]` = `"" + ""` = `""`입니다.
* `{}.toString()` = `"[object Object]"`이므로 `[]+{}` = `"" + "[object Object]"` = `"[object Object]"`가 됩니다.

다만, `{}+[]`는 예외적으로 객체 `{}`와 배열 `[]`을 더하는 것이 아니라 **비어 있는 블록** `{}`과 배열에 단항 덧셈을 하는 식 `+[]`으로 파싱되기 때문에 다른 결과가 나옵니다. 이 값은 <AOut href={h.abs.conv.tonumber.$}>ToNumber</AOut>(<Var>argument</Var> = **[]**), <AOut href={h.abs.conv.toprimitive}>ToPrimitive</AOut>(<Var>input</Var> = **[]**, <Var>preferredType</Var> = NUMBER)를 거쳐 <strong>""</strong>이 된 뒤 <AOut href={h.abs.conv.tonumber.$}>ToNumber</AOut>(<Var>argument</Var> = **""**), <AOut href={h.abs.conv.tonumber.string.stringtonumber}>StringToNumber</AOut>(<Var>str</Var> = **""**), 마지막으로 <AOut href={h.abs.conv.tonumber.string.stringnumericvalue}>StringNumericValue</AOut>(*StringNumericLiteral* ::: <Var>StrWhiteSpace</Var><sub>opt</sub>)의 많은 단계를 거쳐 $$+0_\mathbb{F}$$, 즉 `0`이 됩니다. `+[]` = `0`이라는 내용을 이렇게까지 늘여서 써도 되나...? 참고로 `({}+[])`은 정상적(?)으로 `"[object Object]"`가 됩니다.

### 무엇이 문제일까? \{#array-plus-array-what-went-wrong\}

어... 이건(특히 처음 두 개는) 언어 설계의 잘못이라는 게 개인적인 의견입니다. 혹시 `(!+[]+[]+![]).length`에 흥미가 생기신다면 <AOut href="https://jsfuck.com">이 페이지</AOut>도 확인해 보세요.

## `true+true+true===3`, `true-true` \{#true-plus-true-plus-true\}

### 어떻게 된 걸까? \{#true-plus-true-plus-true-what-happened\}

덧셈 연산자의 평가 알고리즘을 다시 한 번 살펴봅시다. 이 경우에도 <Var>opText</Var>가 `+`입니다.

<Blockquote>
	1. <Var>opText</Var>가 `+`일 경우,
		<ol style="list-style-type: lower-alpha;">
			<li><Var>lPrim</Var>을 ? <AOut href={h.abs.conv.toprimitive}>ToPrimitive</AOut>(<Var>lVal</Var>)로 정한다.</li>
			<li><Var>rPrim</Var>을 ? <AOut href={h.abs.conv.toprimitive}>ToPrimitive</AOut>(<Var>rVal</Var>)로 정한다.</li>
			<li>(중략)</li>
			<li><Var>lVal</Var>을 <Var>lPrim</Var>으로 바꾼다.</li>
			<li><Var>rVal</Var>을 <Var>rPrim</Var>으로 바꾼다.</li>
		</ol>
	1. 참고: 이 시점에 이 연산은 수 연산으로 확정된다.
	1. <Var>lNum</Var>을 ? <AOut href={h.abs.conv.tonumeric}>ToNumeric</AOut>(<Var>lVal</Var>)로 정한다.
	1. <Var>rNum</Var>을 ? <AOut href={h.abs.conv.tonumeric}>ToNumeric</AOut>(<Var>rVal</Var>)로 정한다.
	1. (중략)
	1. <Var>lNum</Var>이 <AOut href={h.type.lang.numeric.bigint}>BigInt일</AOut> 경우,
		<ol style="list-style-type: lower-alpha;">
			<li>(중략)</li>
		</ol>
	1. 그렇지 않을 경우,
		<ol style="list-style-type: lower-alpha;">
			<li>불변조건: <Var>lNum</Var>은 <AOut href={h.type.lang.numeric.number.$}>Number이다</AOut>.</li>
			<li><Var>operation</Var>을 아래 표에서 <Var>opText</Var>에 대응하는 추상 연산으로 정한다. (표 생략)</li>
		</ol>
	1. <Var>operation</Var>(<Var>lNum</Var>, <Var>rNum</Var>)을 반환한다.

	<Fragment slot="original">
		1. If <Var>opText</Var> is `+`,
			<ol style="list-style-type: lower-alpha;">
				<li>Let <Var>lPrim</Var> be ? <AOut href={h.abs.conv.toprimitive}>ToPrimitive</AOut>(<Var>lVal</Var>).</li>
				<li>Let <Var>rPrim</Var> be ? <AOut href={h.abs.conv.toprimitive}>ToPrimitive</AOut>(<Var>rVal</Var>).</li>
				<li>...</li>
				<li>Set <Var>lVal</Var> to <Var>lPrim</Var>.</li>
				<li>Set <Var>rVal</Var> to <Var>rPrim</Var>.</li>
			</ol>
		1. NOTE: At this point. it must be a numeric operation.
		1. Let <Var>lNum</Var> be ? <AOut href={h.abs.conv.tonumeric}>ToNumeric</AOut>(<Var>lVal</Var>).
		1. Let <Var>rNum</Var> be ? <AOut href={h.abs.conv.tonumeric}>ToNumeric</AOut>(<Var>rVal</Var>).
		1. ...
		1. If <Var>lNum</Var> <AOut href={h.type.lang.numeric.bigint}>is a BigInt</AOut>, then
			<ol style="list-style-type: lower-alpha;">
				<li>...</li>
			</ol>
		1. Else,
			<ol style="list-style-type: lower-alpha;">
				<li>Assert: <Var>lNum</Var> <AOut href={h.type.lang.numeric.number.$}>is a Number</AOut>.</li>
				<li>Let <Var>operation</Var> be the abstract operation associated with <Var>opText</Var> in the following table: ...</li>
			</ol>
		1. Return <Var>operation</Var>(<Var>lNum</Var>, <Var>rNum</Var>).
	</Fragment>
</Blockquote>

이때 <AOut href={h.abs.conv.tonumeric}>ToNumeric</AOut>(<Var>value</Var> = **true**)는 <AOut href={h.abs.conv.toprimitive}>ToPrimitive</AOut>(<Var>input</Var> = **true**, <Var>preferredType</Var> = NUMBER)와 <AOut href={h.abs.conv.tonumber.$}>ToNumber</AOut>(<Var>argument</Var> = **true**)를 거쳐 $$1_\mathbb{F}$$, 즉 `1`이 됩니다. 또한 7번째 단계에서 언급한 표를 옮기지는 않겠지만 <Var>opText</Var> = `+`에 대응하는 연산은 <AOut href={h.type.lang.numeric.number.add}>Number::add</AOut>이고, 이 연산은 보통의 덧셈 연산이므로 결과적으로는 $$1 + 1 + 1 = 3$$이 됩니다. `true-true`도 비슷한 과정을 거쳐 $$1 - 1 = 0$$이 됩니다.

### 무엇이 문제일까? \{#true-plus-true-plus-true-what-went-wrong\}

제 개인 의견을 말씀드리자면, `true`에 1을, `false`에 0을 대응시키는 것은 매우 자연스러운 현상이고, JavaScript의 잘못이 있다면 위의 `[]+[]`이나 `[]+{}`처럼 부울을 정수로 *암시적으로* 형변환한 것 정도입니다. 최소한 `[]`을 `""`으로, `{}`를 `"[object Object]"`로 변환한 것보다는 직관적이지 않나요?

### 다른 언어에서도 그럴까? \{#true-plus-true-plus-true-do-other-languages-do-this\}

적어도 C++와 Python에도 부울을 정수로 암시적으로 형변환하는 동작이 있습니다.

```cpp
#include <iostream>
#include <typeinfo>

template<class T> void print_type(T x) {
	std::cout << typeid(x).name() << " " << x << std::endl;
}

int main() {
	print_type(true); // b 1
	print_type(true + true + true); // i 3
	print_type(true - true); // i 0
    return 0;
}
```

```python
def print_type(x):
	print(f"{type(x)} {x}")

print_type(True) # <class 'bool'> True
print_type(True + True + True) # <class 'int'> 3
print_type(True - True) # <class 'int'> 0
```

## `true==1`, `true===1`, `[]==0` \{#true-eqeqeq-1\}

### 어떻게 된 걸까? \{#true-eqeqeq-1-what-happened\}

`==` 연산자의 의미는 <AOut href={h.abs.test.islooselyequal}>7.2.13 IsLooselyEqual(<Var>x</Var>, <Var>y</Var>)</AOut>, `===` 연산자의 의미는 <AOut href={h.abs.test.isstrictlyequal}>7.2.14 IsStrictlyEqual(<Var>x</Var>, <Var>y</Var>)</AOut>에서 정의하고 있는데, 이유는 잘 모르겠지만 연산자의 좌변과 우변이 추상 연산에서는 바뀌어서 호출되고 있습니다. 표준에 '`A == B`와 `B == A`는 `A`와 `B`의 연산 순서를 제외하면 동등하다'는 언급이 있으므로 큰 문제는 없습니다.

<AOut href={h.abs.test.isstrictlyequal}>IsStrictlyEqual</AOut>(<Var>x</Var>, <Var>y</Var>)는 두 값의 타입까지 일치해야 하는 동일성 비교 연산입니다.

<Blockquote>
	1. <AOut href={h.abs.test.sametype}>SameType</AOut>(<Var>x</Var>, <Var>y</Var>)가 **false**일 경우, **false**를 반환한다.
	1. (후략)

	<Fragment slot="original">
		1. If <AOut href={h.abs.test.sametype}>SameType</AOut>(<Var>x</Var>, <Var>y</Var>) is **false**, return **false**.
		1. ...
	</Fragment>
</Blockquote>

<AOut href={h.abs.test.islooselyequal}>IsLooselyEqual</AOut>(<Var>x</Var>, <Var>y</Var>)는 두 값의 타입이 다를 때 형변환을 해서 비교하는 연산입니다.

<Blockquote>
	<ol>
		<li>
			<AOut href={h.abs.test.sametype}>SameType</AOut>(<Var>x</Var>, <Var>y</Var>)가 **true**일 경우,
			<ol style="list-style-type: lower-alpha;">
				<li><AOut href={h.abs.test.isstrictlyequal}>IsStrictlyEqual</AOut>(<Var>x</Var>, <Var>y</Var>)를 반환한다.</li>
			</ol>
		</li>
		<li>(중략)</li>
		<li value="5"><Var>x</Var>가 <AOut href={h.type.lang.numeric.number.$}>Number이고</AOut> <Var>y</Var>가 <AOut href={h.type.lang.string.$}>String일</AOut> 경우, ! <AOut href={h.abs.test.islooselyequal}>IsLooselyEqual</AOut>(<Var>x</Var>, ! <AOut href={h.abs.conv.tonumber.$}>ToNumber</AOut>(<Var>y</Var>))를 반환한다.</li>
		<li>(중략)</li>
		<li value="10"><Var>y</Var>가 <AOut href={h.type.lang.boolean}>Boolean일</AOut> 경우, ! <AOut href={h.abs.test.islooselyequal}>IsLooselyEqual</AOut>(<Var>x</Var>, ! <AOut href={h.abs.conv.tonumber.$}>ToNumber</AOut>(<Var>y</Var>))를 반환한다.</li>
		<li><Var>x</Var>가 String, Number, BigInt, Symbol 중 하나이고 <Var>y</Var>가 <AOut href={h.type.lang.object}>Object일</AOut> 경우, ! <AOut href={h.abs.test.islooselyequal}>IsLooselyEqual</AOut>(<Var>x</Var>, ! <AOut href={h.abs.conv.toprimitive}>ToPrimitive</AOut>(<Var>y</Var>))를 반환한다.</li>
		<li>(후략)</li>
	</ol>

	<Fragment slot="original">
		<ol>
			<li>
				If <AOut href={h.abs.test.sametype}>SameType</AOut>(<Var>x</Var>, <Var>y</Var>) is **true**,
				<ol style="list-style-type: lower-alpha;">
					<li>Return <AOut href={h.abs.test.isstrictlyequal}>IsStrictlyEqual</AOut>(<Var>x</Var>, <Var>y</Var>).</li>
				</ol>
			</li>
			<li>...</li>
			<li value="5">If <Var>x</Var> <AOut href={h.type.lang.numeric.number.$}>is a Number</AOut> and <Var>y</Var> <AOut href={h.type.lang.string.$}>is a String</AOut>, return ! <AOut href={h.abs.test.islooselyequal}>IsLooselyEqual</AOut>(<Var>x</Var>, ! <AOut href={h.abs.conv.tonumber.$}>ToNumber</AOut>(<Var>y</Var>)).</li>
			<li>...</li>
			<li value="10">If <Var>y</Var> <AOut href={h.type.lang.boolean}>is a Boolean</AOut>, return ! <AOut href={h.abs.test.islooselyequal}>IsLooselyEqual</AOut>(<Var>x</Var>, ! <AOut href={h.abs.conv.tonumber.$}>ToNumber</AOut>(<Var>y</Var>)).</li>
			<li>If <Var>x</Var> is either a String, a Number, a BigInt, or a Symbol and <Var>y</Var> <AOut href={h.type.lang.object}>is an Object</AOut>, return ! <AOut href={h.abs.test.islooselyequal}>IsLooselyEqual</AOut>(<Var>x</Var>, ! <AOut href={h.abs.conv.toprimitive}>ToPrimitive</AOut>(<Var>y</Var>)).</li>
			<li>...</li>
		</ol>
	</Fragment>
</Blockquote>

위의 세 비교 연산은 다음 순서대로 진행됩니다.

* `true==1` (<Var>x</Var> = $$1_\mathbb{F}$$, <Var>y</Var> = **true**)
	1. <Var>y</Var>가 Boolean이므로 <Var>y</Var>를 <AOut href={h.abs.conv.tonumber.$}>ToNumber</AOut>(<Var>y</Var>) = $$1_\mathbb{F}$$로 바꾸고 다시 비교합니다. (<Var>x</Var> = $$1_\mathbb{F}$$, <Var>y</Var> = $$1_\mathbb{F}$$)
	1. <Var>x</Var>와 <Var>y</Var>가 같은 타입이므로 <AOut href={h.abs.test.isstrictlyequal}>IsStrictlyEqual</AOut>로 비교합니다.
	1. <Var>x</Var>와 <Var>y</Var>가 **NaN**이 아니고 같은 값을 가지므로 **true**를 반환합니다.
* `true===1` (<Var>x</Var> = $$1_\mathbb{F}$$, <Var>y</Var> = **true**)
	1. <Var>x</Var>와 <Var>y</Var>가 다른 타입이므로 **false**를 반환합니다.
* `[]==0` (<Var>x</Var> = $$+0_\mathbb{F}$$, <Var>y</Var> = **[]**)
	1. <Var>x</Var>가 Number이고 <Var>y</Var>가 Object이므로 <Var>y</Var>를 <AOut href={h.abs.conv.toprimitive}>ToPrimitive</AOut>(<Var>y</Var>) = <strong>""</strong>로 바꾸고 다시 비교합니다. (<Var>x</Var> = $$+0_\mathbb{F}$$, <Var>y</Var> = **""**)
	1. <Var>x</Var>가 Number이고 <Var>y</Var>가 String이므로 <Var>y</Var>를 <AOut href={h.abs.conv.tonumber.$}>ToNumber</AOut>(<Var>y</Var>) = $$+0_\mathbb{F}$$로 바꾸고 다시 비교합니다. (<Var>x</Var> = $$+0_\mathbb{F}$$, <Var>y</Var> = $$+0_\mathbb{F}$$)
	1. <Var>x</Var>와 <Var>y</Var>가 같은 타입이므로 <AOut href={h.abs.test.isstrictlyequal}>IsStrictlyEqual</AOut>로 비교합니다.
	1. <Var>x</Var>와 <Var>y</Var>가 **NaN**이 아니고 같은 값을 가지므로 **true**를 반환합니다.

### 무엇이 문제일까? \{#true-eqeqeq-1-what-went-wrong\}

이것도 `[]+[]`처럼 JavaScript 잘못이 맞아서 제가 뭐라고 할 수가 없긴 한데, 대신 2021년 8월에 봤던 <AOut href="https://algassert.com/visualization/2014/03/27/Better-JS-Equality-Table.html">이 글</AOut>(영어)을 공유해드릴 수는 있을 것 같습니다.

<Image src={x_1426610751238590467} alt={`잇창명의 2021년 8월 15일 X 게시물: "TL;DR: "JS의 == 연산자가 구린 건 맞지만 왼쪽만큼만 구린 걸 오른쪽처럼 만들어서 선동질하지는 마라"". 위에 링크된 글에서 게시한 주황색 표와 초록색 표가 이미지로 첨부되어 있다.`} />

## 결론 \{#conclusion\}

JavaScript의 문제가 아닌 걸 치우고 IEEE 754의 문제만 따로 모아놓으면 이 정도가 됩니다.

<Image src={js} alt={`위의 "Thanks for inventing Javascript" 이미지에서 자바스크립트 자체의 문제인 코드만 남겼다.`} />

<Image src={ieee754} alt={`위의 "Thanks for inventing Javascript" 이미지에서 IEEE 754의 문제인 코드만 남기고 문구를 "Thanks for inventing IEEE 754"로 수정했다.`} />

차라리 JavaScript를 이렇게 깠으면 저도 ~~트위터에~~ ~~X에~~ 블루스카이에 "자바스크립트넘구데기" 같은 자조적인 글을 쓰면서 저 짤을 올렸을 겁니다. 맨 위의 짤은 *JavaScript 자체의 문제가 아닌 것을 슬쩍 끼워넣어서 문제의 본질을 흐리고 있습니다*. 애초에 그냥 웃자고 만든 밈짤인데 민감하게 반응한 감도 없지는 않지만, 누군가는 이 얘기를 해야 한다고 항상 생각하고 있었습니다. 아무튼 저는 할 말을 전부 했으니 여한이 없습니다. 😝